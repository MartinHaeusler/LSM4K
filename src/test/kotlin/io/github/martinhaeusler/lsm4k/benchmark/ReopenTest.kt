package io.github.martinhaeusler.lsm4k.benchmark

import io.github.martinhaeusler.lsm4k.api.DatabaseEngine
import io.github.martinhaeusler.lsm4k.api.TransactionalStore.Companion.withCursor
import java.io.File

/**
 * Reopens a pre-existing database and reads the entire contents, counting the entries in each store.
 *
 * This test is useful to check the integrity of written files.
 */
object ReopenTest {

    private const val PATH = "/tmp/lsm4kPrefetchingBenchmark1706673507404522800"

    @JvmStatic
    fun main(args: Array<String>) {
        val file = File(PATH)
        println("Opening DatabaseEngine...")
        DatabaseEngine.openOnDirectory(file).use { engine ->
            println("DatabaseEngine opened successfully.")

            val timeBefore = System.currentTimeMillis()
            engine.readWriteTransaction { tx ->
                val allStores = tx.allStores
                println("There are ${allStores.size} stores in this instance: ${allStores.joinToString { it.storeId.toString() }}")
                for (store in allStores) {
                    println("Iterating over store '${store.storeId}'...")
                    store.withCursor { cursor ->
                        if (!cursor.first()) {
                            println("Store '${store.storeId}' has 0 entries.")
                        } else {
                            val count = cursor.ascendingEntrySequenceFromHere().count()
                            println("Store '${store.storeId}' has ${count} entries.")
                        }
                    }
                }
            }
            val timeAfter = System.currentTimeMillis()
            println("Iterated entire store in ${timeAfter - timeBefore}ms.")
            println("Closing DatabaseEngine instance...")
        }
        println("DatabaseEngine closed successfully, exiting.")
    }

}