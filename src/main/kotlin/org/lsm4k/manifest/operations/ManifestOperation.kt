package org.lsm4k.manifest.operations

import com.fasterxml.jackson.annotation.JsonSubTypes
import com.fasterxml.jackson.annotation.JsonTypeInfo
import org.lsm4k.api.exceptions.ManifestException
import org.lsm4k.impl.annotations.PersistentClass
import org.lsm4k.impl.annotations.PersistentClass.Format
import org.lsm4k.manifest.Manifest
import org.lsm4k.util.Timestamp

/**
 * Manifest operations are written into the store manifest file.
 *
 * They are used to track the organizational state of the store, which includes:
 *
 * - Which stores exist? What are their settings and IDs?
 *
 * - Which files exist within each store? Where in the LSM Tree are they located?
 *
 *
 * The key concepts are:
 *
 * - The manifest file is append-only. New operations can be added, but existing ones cannot be changed.
 *
 * - The operations must provide enough information to be replayed in case of errors.
 *
 * - In order to prevent indefinite growth of the file, we periodically take the current state and write it into
 *   a new manifest file as a "checkpoint". This checkpoint contains a snapshot of the entire store state, and
 *   this operation may occur only as the first position in a manifest file. Once a checkpoint is taken, the
 *   old manifest file as a whole gets replaced with the new file (containing only one operation).
 */
@PersistentClass(format = Format.JSON, details = "Used in Manifest")
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type")
@JsonSubTypes(
    JsonSubTypes.Type(
        value = CheckpointOperation::class,
        name = "checkpoint",
    ),
    JsonSubTypes.Type(
        value = FlushOperation::class,
        name = "flush",
    ),
    JsonSubTypes.Type(
        value = CreateStoreOperation::class,
        name = "createStore",
    ),
    JsonSubTypes.Type(
        value = DeleteStoreOperation::class,
        name = "deleteStore",
    ),
    JsonSubTypes.Type(
        value = LeveledCompactionOperation::class,
        name = "leveledCompaction",
    ),
    JsonSubTypes.Type(
        value = TieredCompactionOperation::class,
        name = "tieredCompaction",
    ),
    JsonSubTypes.Type(
        value = FullCompactionOperation::class,
        name = "fullCompaction",
    ),
)
sealed interface ManifestOperation : Comparable<ManifestOperation> {

    /**
     * The sequence number of this operation.
     *
     * Must be unique within all operations. Operations must be applied
     * strictly in order onto an existing manifest in order to be valid.
     *
     * For example, if the manifest was generated by operation 7, the
     * next operation must have an [sequenceNumber] of 8.
     */
    val sequenceNumber: Int

    /** The wall clock timestamp of the creation of the operation. */
    val wallClockTime: Timestamp

    /**
     * Applies this operation to the given [manifest].
     *
     * @param manifest The manifest to update. Manifests are immutable, therefore a new manifest will be produced.
     *
     * @return The updated manifest. The input [manifest] will not be changed.
     *
     * @throws ManifestException if the operation could not be applied.
     */
    fun applyToManifest(manifest: Manifest): Manifest

    override fun compareTo(other: ManifestOperation): Int {
        return this.sequenceNumber.compareTo(other.sequenceNumber)
    }

}